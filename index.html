<!DOCTYPE html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=1024">
	<meta name="keywords" content="pso,d3,particle,swarm,optimization,interactive,javascript">
	<meta itemprop="description" name="description" content="Particle Swarm Optimization Interactive Javascript Applet">
	<meta name="author" content="Marc Normandin">
	
	<link rel="stylesheet" type="text/css" href="style.css">
	
	<title>Particle Swarm Optimization Interactive Demonstration by Marc Normandin</title>
	
	<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
	<!-- <script src="jquery-1.11.3.js"></script> -->
	
	<script src="pso.js"></script>
	<script src="pso_plot.js"></script>

</head>

<body>

<div class="header">
<center>
<h2>Particle Swarm Optimization</h2>
<h3>Demonstration of <a href="https://github.com/marcnormandin/pso_js">pso_js</a> javascript code</h3>
<h4>Written by <i>Marc Normandin</i></h4>
</center>
</div> <!-- header -->

<br/>
<div class="pso_simulation">
<div class="pso_plot">
<div class="tab-panels">
		<ul class="tabs">
			<li rel="panelBasic">Basic</li>
			<li rel="panelWeights">Weights</li>
			<li rel="panelStoppingCondition">Stopping Condition</li>
			<li rel="panelDisplay">Display</li>
			<li rel="panelLegend">Legend</li>
		</ul>

		<div id="panelBasic" class="panel">
			<table>
				<tr>
					<td>Function</td>
					<td>
							<select id="inputFunction" onchange="startSimulation()">
							  <option value="Salomon">Function: Salomon</option>
							  <option value="Bohachevsky">Function: Bohachevsky</option>
							  <option value="Griewank">Function: Griewank</option>
							  <option value="Michaelwicz">Function: Michaelwicz</option>
							  <option value="Image: Noise #1">Image: Noise #1</option>
							  <option value="Image: Spiral">Image: Spiral</option>
							</select>
					</td>
					<td class="parameterHelpText">the function to minimize</td>
				</tr>
				<tr>
					<td>Topology</td>
					<td>
							<select id="inputTopology">
							  <option value="Ring">Ring (local best)</option>
							  <option value="Fully Connected">Fully Connected (global best)</option>
							</select>
					</td>
					<td class="parameterHelpText">how the particles communicate</td>
				</tr>
				<tr>
					<td># Neighbors</td>
					<td><input type="number" id="inputNumNeighbors" value="2"/></td>
					<td class="parameterHelpText">particle's peers<br/> (must be even #)</td>
				</tr>
				<tr>
					<td># Particles</td>
					<td><input type="number" id="inputNumParticles" value="50"/></td>
					<td class="parameterHelpText"></td>
				</tr>
				<tr>
					<td>Iterations per second</td>
					<td><input type="number" id="inputIterationsPerSecond" value="20"/></td>
				</tr>
		<tr>
    		</table>
		</div>

		<div id="panelWeights" class="panel">
			<table>
				<tr>
					<td>Inertial weight (Begin)</td>
					<td><input type="number" id="inputInertiaWeightBegin" value="0.72984"/></td>
					<td class="parameterHelpText">particle's perseverance</td>
				</tr>
				<tr>
					<td>Inertial weight (End)</td>
					<td><input type="number" id="inputInertiaWeightEnd" value="0.72984"/></td>
					<td class="parameterHelpText">particle's perseverance</td>
				</tr>
				<tr>
					<td>Inertial weight (Range)</td>
					<td><input type="number" id="inputInertiaWeightIterationRange" value="1"/></td>
					<td class="parameterHelpText">number of iterations to scale over</td>
				</tr>
				<tr>
					<td>Social weight</td>
					<td><input type="number" id="inputSocialWeight" value="1.496172"/></td>
					<td class="parameterHelpText">particle's peer pressure</td>
				</tr>
				<tr>
					<td>Cognitive weight</td>
					<td><input type="number" id="inputCognitiveWeight" value="1.496172"/></td>
					<td class="parameterHelpText">particle's independence</td>
				</tr>
			</table>
		</div>

		<div id="panelStoppingCondition" class="panel">
			<table>
				<tr>
					<td>Stopping condition</td>
					<td>
							<select id="inputStoppingCondition">
							  <option value="none">Never</option>
							  <option value="25">25 iterations</option>
							  <option value="50">50 iterations</option>
							  <option value="100">100 iterations</option>
							  <option value="200">200 iterations</option>
							  <option value="300">300 iterations</option>
							  <option value="400">400 iterations</option>
							  <option value="500" selected="selected">500 iterations</option>
							</select>
					</td>
					<td style="text-align: right;">
						(current iteration #<span id="outputNumIterations"></span>)
					</td>
				</tr>
			</table>
		</div>

		<div id="panelDisplay" class="panel">
			<table>
				<tr>
					<td>Particle radius</td>
					<td><input type="number" id="inputParticleRadius" value="6"/></td>
					<td class="parameterHelpText">radius of particles in pixels</td>
				</tr>
				<tr>
					<td>Best Particle radius</td>
					<td><input type="number" id="inputBestParticleRadius" value="6"/></td>
					<td class="parameterHelpText">radius of best particle in pixels</td>
				</tr>
				<tr>
					<td>Best Minimum radius</td>
					<td><input type="number" id="inputMinimumRadius" value="10"/></td>
					<td class="parameterHelpText">radius of minimum in pixels</td>
				</tr>
				
				<tr>
					<td>
						Display Dust
					</td>
					<td>
						<input type="checkbox" id="inputDisplayDust" checked/>
					</td>
					<td class="parameterHelpText">display visited particle locations</td>
				</tr>
				<tr>
					<td>
						Display lbests
					</td>
					<td>
						<input type="checkbox" id="inputDisplayLBests" checked/>
					</td>
					<td class="parameterHelpText" onchange="this.updateDisplayLBests()">display each particles' local best</td>
				</tr>
				<tr>
					<td>LBest radius</td>
					<td><input type="number" id="inputLBestRadius" value="8"/></td>
					<td class="parameterHelpText">radius of lbest coordinates in pixels</td>
				</tr>
				<tr>
					<td>Background dimension</td>
					<td><input type="number" id="inputSampleGridSize" value="100"/></td>
					<td class="parameterHelpText">Size of background sample grid</td>
				</tr>
			</table>
		</div>
		
		<div id="panelLegend" class="panel">
		<center>
			<ul style="list-style-type: none;">
				<li><span style="color: red;">red</span> are particle current locations</li>
				<li><span style="color: purple;">purple</span> are particle local best locations</li>
				<li><span style="color: yellow;">yellow</span> is the best overall minimum found</li>
				<li><span style="color: green;">green</span> is the particle that found the best minimum</li>
			</ul>
			</center>
		</div>
	</div> <!-- panel-tabs -->
	
		<svg id="plot" width="500" height="500" onclick="plot.toggleAnimation()"></svg>
		<button id="toggleSimulationButton" class="inactive" onclick="toggleSimulation()"></button>
	</div> <!-- pso_plot -->	

	<!-- this is hidden. required for getting pixel data from the canvas. -->
	<canvas id="outputPlotImageCanvas" width="200" height="200" style="display: none;"> </canvas>
</div> <!-- pso_simulation -->

<div style="clear:both;"></div>




<center>
<p>The best position found is: <span id="outputBestPosition"></span></p>
<p>The true global minimum is: <span id="outputTruePosition"></span></p>
</center>		

<center>
<br/>
<br/>
<br/>
<br/>
<br/>
<hr/>

<h3 class="subtitle">A three-dimensional plot of the function being minimized</h3>
<img id="outputPlotImageThreeD"/>

<hr/>

<br/>
<br/>
<br/>
<br/>
<br/>
<h3 class="subtitle">A two-dimensional contour plot of the function being minimized</h3>
<img id="outputPlotImageContour"/>
</center>

<div class="footer">
<h4>Written by <a href="http://github.com/marcnormandin">Marc Normandin</a>, &copy;2015</h4>
</div><!-- footer -->

		
<script>
	"use strict"
	var numIterations = 0;
	var maxIterations = Infinity;
	
	// default value
	var simulationIsRunning = false;

	var plot = undefined;
	var manager = undefined;
	var ff = undefined;
	
	function toggleSimulation() {
		if (!simulationIsRunning) {
			startSimulation();
		} else {
			stopSimulation();
		}
	}
	
	function stopSimulation() {
		simulationIsRunning = false;
		plot.stopAnimation = true;
		document.getElementById("toggleSimulationButton").innerHTML = "Start Simulation";
		document.getElementById("toggleSimulationButton").className = "inactive";
	}
	
	// Convert from PSO scale to Function scale
	function scale(xPSO, dimension) {
		var functionX = (0.5*dimension.max*(1+xPSO) + 0.5*dimension.min*(1-xPSO));
		return functionX;
	}
	
	// This is called every iteration of the PSO algorithm
	function iterationCallback (manager) {
		var x = scale(manager.bestPosition[0], ff.dimensions[0]);
		var y = scale(manager.bestPosition[1], ff.dimensions[1]);
		
		document.getElementById("outputBestPosition").innerHTML
			= "( " + x.toFixed(3) + ", " + y.toFixed(3) + " )";
		
		numIterations++;
		
		document.getElementById("outputNumIterations").innerHTML
			= numIterations;
			
		if (numIterations >= maxIterations) {
			stopSimulation();
			return false;
		}
		
		return true;
	}

	function displayContour (name) {
		// Display the contour if one is present
		if (name != "") {
			document.getElementById("outputPlotImageContour").style.display = "initial";
			document.getElementById("outputPlotImageContour").setAttribute("src", name);
		} else {
			document.getElementById("outputPlotImageContour").style.display = "none";
		}
	}
	
	function displayThreeD (name) {
		if (name != "") {
			document.getElementById("outputPlotImageThreeD").style.display = "initial";
			document.getElementById("outputPlotImageThreeD").setAttribute("src", name);
		} else {
			document.getElementById("outputPlotImageThreeD").style.display = "none";
		}
	}
	
	
	/*
		This is the main function in this HTML file.
		
		It begins a new simulation by querying the input elements
		for their data, and then creating a new PSO computation object
		as well as a new PSO plot animation object.
	*/
function startSimulation() {
	// Check if any current simulation is running. If so, end it.
	if (typeof plot !== 'undefined') {
		plot.stopAnimation = true;
	}
	
	document.getElementById("toggleSimulationButton").className = "active";




	numIterations = 0;
	
	
	
	var FF_Salomon = function() {
	
		this.dimensions = [ {min: -4, max: 4}, {min: -4, max: 4} ];
		this.global = {x: 0, y: 0};
		this.imageSrcContour = "http://i.imgur.com/3dg4gAL.jpg";
		this.imageSrcThreeD = "http://i.imgur.com/KcOFABP.png";
		
		this.compute = function (x, y) 
						{
							//console.log(this.dimensions[0].min);
							x = scale(x, this.dimensions[0]);
							y = scale(y, this.dimensions[1]);
							if ((x >= this.dimensions[0].min) && (x <= this.dimensions[0].max)
								&& (y >= this.dimensions[1].min) && (y <= this.dimensions[1].max)) 
							{
								var r = Math.sqrt(x*x + y*y);
								var f = 1 - Math.cos(2*Math.PI*r) + 0.1*r;
								return f;
							} else {
								return Infinity;
							}
						}
					.bind(this);
	};
	
	var FF_Bohachevsky = function() {
	
		this.dimensions = [ {min: -2, max: 2}, {min: -2, max: 2} ];
		this.global = {x: 0, y: 0};
		this.imageSrcContour = "http://i.imgur.com/phIMicg.png";
		this.imageSrcThreeD = "http://i.imgur.com/DZj4zdU.png";

		
		this.compute = function (x, y) 
						{
							//console.log(this.dimensions[0].min);
							x = scale(x, this.dimensions[0]);
							y = scale(y, this.dimensions[1]);
							if ((x >= this.dimensions[0].min) && (x <= this.dimensions[0].max)
								&& (y >= this.dimensions[1].min) && (y <= this.dimensions[1].max)) 
							{
								var f = x*x + 2 *y*y - 0.3*Math.cos(2*Math.PI*x) - 0.4*Math.cos(4*Math.PI*y) + 0.7;

								return f;
							} else {
								return Infinity;
							}
						}
					.bind(this);
	};
	
	var FF_Griewank = function() {
	
		this.dimensions = [ {min: -40, max: 40}, {min: -40, max: 40} ];
		this.global = {x: 0, y: 0};
		this.imageSrcContour = "http://i.imgur.com/vKt5dVe.png";
		this.imageSrcThreeD = "http://i.imgur.com/auPzgxp.png";

		this.compute = function (x, y) {
			x = scale(x, this.dimensions[0]);
			y = scale(y, this.dimensions[1]);
			if ((x >= this.dimensions[0].min) && (x <= this.dimensions[0].max)
				&& (y >= this.dimensions[1].min) && (y <= this.dimensions[1].max)) 
			{
				var f = 1 + ((1/4000)*(x*x+y*y))-(Math.cos(x)*Math.cos(y/Math.sqrt(2)));
				
				return f;
			} else {
				return Infinity;
			}
		}.bind(this);
	};
	
	var FF_Michaelwicz = function() {
	
		this.dimensions = [ {min: 0, max: 4}, {min: 0, max: 4} ];
		this.global = {x: 2.20319, y: 1.57049};
		this.imageSrcContour = "http://i.imgur.com/aHZ4751.png";
		this.imageSrcThreeD = "http://i.imgur.com/gNmFkhF.png";
		
		this.compute = function (x, y) {
			x = scale(x, this.dimensions[0]);
			y = scale(y, this.dimensions[1]);
			if ((x >= this.dimensions[0].min) && (x <= this.dimensions[0].max)
				&& (y >= this.dimensions[1].min) && (y <= this.dimensions[1].max)) 
			{
				var a = Math.sin(x*x / Math.PI);
				var b = Math.sin(2*y*y / Math.PI);
				var a20 = 1;
				var b20 = 1;
				for (var i = 0; i < 20; i++) {
					a20 *= a;
					b20 *= b;
				}
				var f = -Math.sin(x)*a20 - Math.sin(y)*b20;
				
				return f;
			} else {
				return Infinity;
			}
		}.bind(this);
	};
	
	/*
		This Fitness Function uses an image (translated to grey-scale) as the fitness function values.
		It assumes fixed 200x200 pixel images.
		
		It works by rendering an image to a 'canvas', and then querying that canvas for the pixel values.
		The downside is that the canvas is rendered, when not needed.
	*/
	var FF_Image = function(filename) 
	{
		this.imageSrc = filename;
		this.imageSrcContour = "";
		this.imageSrcThreeD = "";
		
		this.myImg = new Image();
		this.myImg.src = filename;
		this.context = document.getElementById('outputPlotImageCanvas').getContext('2d');
		this.context.drawImage(this.myImg, 0, 0);
		
		// Pictures are assumed to be 200x200 pixels		
		var w = 200;
		var h = 200;
		this.dimensions = [ {min: 0, max: w}, {min: 0, max: h} ];
		
		this.compute = function (x, y) 
						{
							x = scale(x, this.dimensions[0]);
							y = scale(y, this.dimensions[1]);
							//console.log(this.dimensions[0].max);
							if ((x >= this.dimensions[0].min) && (x <= this.dimensions[0].max)
								&& (y >= this.dimensions[1].min) && (y <= this.dimensions[1].max)) 
							{
								var sample_x = x;
								var sample_y = this.dimensions[1].max - y;
								// Returns an ImageData object that copies the pixel data for the specified rectangle on a canvas
								var pixelData = this.context.getImageData(Math.floor(sample_x), Math.floor(sample_y), 1, 1).data;
								var f = 255 - (pixelData[0] + pixelData[1] + pixelData[2]);
								
								return f;
							} else {
								return Infinity;
							}
						}.bind(this);
	};
	
	// Load the user chosen fitness function
	switch (document.getElementById("inputFunction").value) {
		case "Salomon":
			ff = new FF_Salomon;
			break;
		case "Bohachevsky": 
  			ff = new FF_Bohachevsky;
  			break;
		case "Griewank":
			ff = new FF_Griewank;
			break;
		case "Michaelwicz":
			ff = new FF_Michaelwicz;
			break;
		case "Image: Noise #1":
			ff = new FF_Image("http://www.revisemri.com/tools/kspace/images/k_randnoise.jpg");
			break;
		case "Image: Spiral":
			ff = new FF_Image("http://www.gifwave.com/media/102045_art-processing-adam-ferriss-p5-ellipse_200s.gif");
			break;
		default:
			console.assert(false);
	}
	
	displayContour(ff.imageSrcContour);
	displayThreeD(ff.imageSrcThreeD);
	
	if (typeof(ff.global) !== 'undefined') {
		document.getElementById("outputTruePosition").innerHTML = "( " + ff.global.x.toFixed(3) + ", " + ff.global.y.toFixed(3) + " )";
	} else {
		document.getElementById("outputTruePosition").innerHTML = "<i>not applicable</i>";
	}
	
	var ips = parseFloat(document.getElementById("inputIterationsPerSecond").value);
	var numParticles = parseFloat(document.getElementById("inputNumParticles").value);
	
	// Create the main PSO computation object
	manager = new PSO.Manager( ff, numParticles );
	manager.setInertiaScaling(true, 
		parseFloat(document.getElementById("inputInertiaWeightBegin").value),
		parseFloat(document.getElementById("inputInertiaWeightEnd").value),
		parseFloat(document.getElementById("inputInertiaWeightIterationRange").value) );
	//this.manager.inertiaWeight = parseFloat(document.getElementById("inputInertiaWeight").value);
	manager.socialWeight = parseFloat(document.getElementById("inputSocialWeight").value);
	manager.cognitiveWeight = parseFloat(document.getElementById("inputCognitiveWeight").value);
	
	switch (document.getElementById("inputTopology").value) {
		case "Ring":
			manager.topology = "ring";
			manager.numNeighbors = parseFloat(document.getElementById("inputNumNeighbors").value);
			break;
		case "Fully Connected":
			// this should be the manger's default (but set it to be sure)
			manager.topology = "fully connected";
			manager.numNeighbors = parseFloat(this.manager.particles.length);
			break;
		default:
			console.assert(false);
	}
	
	// Create the PSO plot animator object
	plot = new PSOPlot (manager, "plot");
	plot.normalParticleRadius = parseFloat(document.getElementById("inputParticleRadius").value);
	plot.bestParticleRadius = parseFloat(document.getElementById("inputBestParticleRadius").value);
	plot.bestMinimumRadius = parseFloat(document.getElementById("inputMinimumRadius").value);
	plot.sampleNumSize = parseFloat(document.getElementById("inputSampleGridSize").value);
	plot.tickCallbackCallback = iterationCallback.bind(this);
	plot.iterationsPerSecond = ips;
	if (document.getElementById("inputDisplayDust").checked) {
		plot.featureDisplayDustEnabled = true;
	} else {
		plot.featureDisplayDustEnabled = false;
	}
	
	if (document.getElementById("inputDisplayLBests").checked) {
		plot.featureDisplayLBests = true;
	} else {
		plot.featureDisplayLBests = false;
	}
	plot.lbestRadius = parseFloat(document.getElementById("inputLBestRadius").value);
	
	plot.startAnimation();
	
	// Set the animation and computation stopping condition
	switch (document.getElementById("inputStoppingCondition").value) 
	{
		case "none":
			maxIterations = Infinity;
			break;
		case "25":
			maxIterations = 25;
			break;
		case "50":
			maxIterations = 50;
			break;
		case "100":
			maxIterations = 100;
			break;
		case "200":
			maxIterations = 200;
			break;
		case "300":
			maxIterations = 300;
			break;
		case "400":
			maxIterations = 400;
			break;
		case "500":
			maxIterations = 500;
			break;
		default:
			console.log("Invalid stopping condition.");
		 	console.assert(true);
	}
	
	simulationIsRunning = true;
	document.getElementById("toggleSimulationButton").innerHTML = "Stop Simulation";
}

toggleSimulation();

	
</script>

<script>
	"use strict"
	$(function() {
		
		$('.tab-panels .tabs li').on('click', function() {
			// Time to open a panel
			var panelOpenSpeedMs = 250;

			// Time to close a panel
			var panelCloseSpeedMs = 250;

			// Get the particular tab-panel the 'tab' is part of
			var panel = $(this).closest('.tab-panels');
			
			// The current 'active' tab (this can be null)
			var activeTab = panel.find('.tabs li.active');
			
			// The current 'active' panel (this can be null)
			var activePanel = panel.find('.panel.active');
			
			// The selected tab (this can NOT be null)
			var selectedTab = $(this);
			
			// The associated selected panel (this can NOT be null)
			var panelToShowRel = $(this).attr('rel');
			var panelToShow = $('#'+panelToShowRel);

			// The 'active' tab should go inactive (no matter what)
			if (activeTab.length) {
				activeTab.removeClass("active");
			} else {
				// no tab to remove 'active' from
			}
			
			// If the selected tab is not the active tab, then make it active
			if (!(selectedTab.is(activeTab))) {
				selectedTab.addClass("active");
			} else {
				// the active tab was clicked on, so no other
				// active tab to highlight
			}
			
			// If the active tab was selected, no panels should be open
			if (selectedTab.is(activeTab)) {
				// If the active panel exists, close it
				if (activePanel.length) {
					activePanel.slideUp(panelCloseSpeedMs, function() {
						activePanel.removeClass("active");
					});
				} else {
					// there is no active panel to hide
				}
			} else {
				if (activePanel.length) {
					// A panel is already open, so close it, then open the new one.
					activePanel.slideUp(panelCloseSpeedMs, function() {
						activePanel.removeClass('active');
						panelToShow.slideDown(panelOpenSpeedMs, function() {
							panelToShow.addClass('active');
						});
					});
				} else {
					// No panel is open, so just open the new one
					panelToShow.slideDown(panelOpenSpeedMs, function() {
						panelToShow.addClass("active");
					});
				}
			}
		});
	
	});
</script>

</body>

</html>
