<!DOCTYPE html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=1024">
	<meta name="keywords" content="pso,d3,particle,swarm,optimization,interactive,javascript">
	<meta itemprop="description" name="description" content="Particle Swarm Optimization Interactive Javascript Applet">
	<meta name="author" content="Marc Normandin">
	
	<title>Particle Swarm Optimization Interactive Demonstration</title>
	<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>	
	<script src="pso.js"></script>
	<script src="pso_plot.js"></script>

	<style>

		svg {
			outline: black solid thick;
			margin-left: auto;
			margin-right: auto;
		}
		
		div.pso_simulation {
			margin-left: auto;
			margin-right: auto;
			margin-top: auto;
			margin-bottom: auto;
			vertical-align: middle;
			height: 525px;
			width: 1200px;
		}
		
		div.plot_info {
			background-color: transparent;
			display: inline-block;
			margin-left: auto;
			margin-right: auto;
			text-align: justify;
			vertical-align: middle;
			width: 600px;
		}
		
		div.pso_plot {
			width: 525px;
			height: 525px;
			background-color: transparent;
			display: inline-block;
			float: left;
			margin-left: auto;
			margin-right: auto;
			vertical-align: middle;
		}
		
		#outputPlotImageContour, #outputPlotImageThreeD {
			width: 800px;
			height: 600px;
		}

		p {
			text-transform: uppercase;
		}
		
		span {
			font-size: 1.5em;
		}
		
		img#outputPlotImage {
			width: 200px;
			height: 200px;
		}
		
		.parameterHelpText {
			font-style: italic;
			font-weight: lighter;
		}
		
		td {
			text-align: left;
		}
		
		.subtitle {
			text-transform: uppercase;
		}
		
		button {
			width: 400px;
			height: 50px;
			text-transform: uppercase;
			font-weight: bold;
		}
		
	</style>
</head>

<body>
<center>
<h1>Particle Swarm Optimization:</h1>
<h2>Demonstration of <a href="https://github.com/marcnormandin/pso_js">pso_js</a> javascript code.</h2>
<h4>Written by Marc Normandin</h4>
<hr/>
</center>

<br/>
<div class="pso_simulation">
	<div class="pso_plot">
		<svg id="plot" width="500" height="500" onclick="plot.toggleAnimation()"></svg>
	</div>

	<div class="plot_info">
	<table>
		<tr>
			<td>Function</td>
			<td>
					<select id="inputFunction" onchange="startSimulation()">
					  <option value="Salomon">Salomon</option>
					  <option value="Bohachevsky">Bohachevsky</option>
					  <option value="Griewank">Griewank</option>
					  <option value="Michaelwicz">Michaelwicz</option>
					</select>
			</td>
			<td class="parameterHelpText">the function to minimize</td>
		</tr>
		<tr>
			<td>Topology</td>
			<td>
					<select id="inputTopology">
					  <option value="Ring">Ring (local best)</option>
					  <option value="Star">Star (global best)</option>
					</select>
			</td>
			<td class="parameterHelpText">how the particles communicate</td>
		</tr>
		<tr>
			<td># Neighbors (even #)</td>
			<td><input type="text" id="inputNumNeighbors" value="4"/></td>
			<td class="parameterHelpText">how many particles each particle communicates directly with</td>
		</tr>
		<tr>
			<td># Particles</td>
			<td><input type="text" id="inputNumParticles" value="20"/></td>
			<td class="parameterHelpText"></td>
		</tr>
	<tr>
		<td>Inertial weight</td>
		<td><input type="text" id="inputInertiaWeight" value="0.9"/></td>
		<td class="parameterHelpText">how much a particle maintains its previous velocity</td>
	</tr>
	<tr>
		<td>Social weight</td>
		<td><input type="text" id="inputSocialWeight" value="0.1"/></td>
		<td class="parameterHelpText">how much a particle is influenced by its peers</td>
	</tr>
	<tr>
		<td>Cognitive weight</td>
		<td><input type="text" id="inputCognitiveWeight" value="0.2"/></td>
		<td class="parameterHelpText">how much a particle is influenced by its memory</td>
	</tr>
	<tr>
		<td>Iterations per second</td>
		<td><input type="text" id="inputIterationsPerSecond" value="30"/></td></tr>
	<tr>
			<td>Stopping condition</td>
			<td>
					<select id="inputStoppingCondition">
					  <option value="none">None</option>
					  <option value="100">100 iterations</option>
					  <option value="200">200 iterations</option>
					  <option value="300">300 iterations</option>
					  <option value="400">400 iterations</option>
					  <option value="500">500 iterations</option>
					</select>
			</td>
	</tr>
	</table>
	<button id="toggleSimulationButton" onclick="toggleSimulation()"></button>
	
	
		<p>
			The best position found is: <span id="outputBestPosition"></span>
		</p>
		<p>
			The true global minimum is: <span id="outputTruePosition"></span>
		</p>
		
		<p>
			Iteration # <span id="outputNumIterations"></span>
		</p>
		
		

		<canvas id="outputPlotImageCanvas" width="200" height="200"> </canvas>
	</div>
</div>


<div style="clear:both;"></div>

<center>
<hr/>

<h3 class="subtitle">A three-dimensional plot of the function being minimized</h3>
<img id="outputPlotImageThreeD"/>

<hr/>

<h3 class="subtitle">A two-contour plot of the function being minimized</h3>
<img id="outputPlotImageContour"/>
<hr/>
<h4>Written by Marc Normandin, 2015</h4>
</center>

		
<script>
	var numIterations = 0;
	var maxIterations = Infinity;
	
	// default value
	this.simulationIsRunning = false;
	
	function toggleSimulation() {
		if (!this.simulationIsRunning) {
			startSimulation();
		} else {
			stopSimulation();
		}
	}
	
	function stopSimulation() {
		this.simulationIsRunning = false;
		this.plot.stopAnimation = true;
		document.getElementById("toggleSimulationButton").innerHTML = "Start Simulation";
	}
	
	// Convert from PSO scale to Function scale
	function scale(xPSO, dimension) {
		var functionX = (0.5*dimension.max*(1+xPSO) + 0.5*dimension.min*(1-xPSO));
		return functionX;
	}
	
	// This is called every iteration of the PSO algorithm
	function iterationCallback (manager) {
		var x = scale(manager.bestPosition[0], this.ff.dimensions[0]);
		var y = scale(manager.bestPosition[1], this.ff.dimensions[1]);
		document.getElementById("outputBestPosition").innerHTML
			= "( " + x.toFixed(3) + ", " + y.toFixed(3) + " )";
		
		numIterations++;
		
		document.getElementById("outputNumIterations").innerHTML
			= numIterations;
			
		if (numIterations >= maxIterations) {
			return false;
		}
		
		return true;
	}

	
	
	/*
		This is the main function in this HTML file.
		
		It begins a new simulation by querying the input elements
		for their data, and then creating a new PSO computation object
		as well as a new PSO plot animation object.
	*/
function startSimulation() {
	// Check if any current simulation is running. If so, end it.
	if (typeof this.plot !== 'undefined') {
		this.plot.stopAnimation = true;
	}
	
	numIterations = 0;
	
	
	
	var FF_Salomon = function() {
	
		this.dimensions = [ {min: -4, max: 4}, {min: -4, max: 4} ];
		this.global = {x: 0, y: 0};
		this.imageSrcContour = "http://i.imgur.com/3dg4gAL.jpg";
		this.imageSrcThreeD = "http://i.imgur.com/KcOFABP.png";
		
		this.compute = function (x, y) 
						{
							//console.log(this.dimensions[0].min);
							x = scale(x, this.dimensions[0]);
							y = scale(y, this.dimensions[1]);
							if ((x >= this.dimensions[0].min) && (x <= this.dimensions[0].max)
								&& (y >= this.dimensions[1].min) && (y <= this.dimensions[1].max)) 
							{
								var r = Math.sqrt(x*x + y*y);
								var f = 1 - Math.cos(2*Math.PI*r) + 0.1*r;
								return f;
							} else {
								return Infinity;
							}
						}
					.bind(this);
	};
	
	var FF_Bohachevsky = function() {
	
		this.dimensions = [ {min: -2, max: 2}, {min: -2, max: 2} ];
		this.global = {x: 0, y: 0};
		this.imageSrcContour = "http://i.imgur.com/phIMicg.png";
		this.imageSrcThreeD = "http://i.imgur.com/DZj4zdU.png";

		
		this.compute = function (x, y) 
						{
							//console.log(this.dimensions[0].min);
							x = scale(x, this.dimensions[0]);
							y = scale(y, this.dimensions[1]);
							if ((x >= this.dimensions[0].min) && (x <= this.dimensions[0].max)
								&& (y >= this.dimensions[1].min) && (y <= this.dimensions[1].max)) 
							{
								var f = x*x + 2 *y*y - 0.3*Math.cos(2*Math.PI*x) - 0.4*Math.cos(4*Math.PI*y) + 0.7;

								return f;
							} else {
								return Infinity;
							}
						}
					.bind(this);
	};
	
	var FF_Griewank = function() {
	
		this.dimensions = [ {min: -40, max: 40}, {min: -40, max: 40} ];
		this.global = {x: 0, y: 0};
		this.imageSrcContour = "http://i.imgur.com/vKt5dVe.png";
		this.imageSrcThreeD = "http://i.imgur.com/auPzgxp.png";

		this.compute = function (x, y) {
			x = scale(x, this.dimensions[0]);
			y = scale(y, this.dimensions[1]);
			if ((x >= this.dimensions[0].min) && (x <= this.dimensions[0].max)
				&& (y >= this.dimensions[1].min) && (y <= this.dimensions[1].max)) 
			{
				var f = 1 + ((1/4000)*(x*x+y*y))-(Math.cos(x)*Math.cos(y/Math.sqrt(2)));
				
				return f;
			} else {
				return Infinity;
			}
		}.bind(this);
	};
	
	var FF_Michaelwicz = function() {
	
		this.dimensions = [ {min: 0, max: 4}, {min: 0, max: 4} ];
		this.global = {x: 2.20319, y: 1.57049};
		this.imageSrcContour = "http://i.imgur.com/aHZ4751.png";
		this.imageSrcThreeD = "http://i.imgur.com/gNmFkhF.png";
		
		this.compute = function (x, y) {
			x = scale(x, this.dimensions[0]);
			y = scale(y, this.dimensions[1]);
			if ((x >= this.dimensions[0].min) && (x <= this.dimensions[0].max)
				&& (y >= this.dimensions[1].min) && (y <= this.dimensions[1].max)) 
			{
				var a = Math.sin(x*x / Math.PI);
				var b = Math.sin(2*y*y / Math.PI);
				var a20 = 1;
				var b20 = 1;
				for (var i = 0; i < 20; i++) {
					a20 *= a;
					b20 *= b;
				}
				var f = -Math.sin(x)*a20 - Math.sin(y)*b20;
				
				return f;
			} else {
				return Infinity;
			}
		}.bind(this);
	};
	
	/*
		This Fitness Function uses an image (translated to grey-scale) as the fitness function values.
		It assumes fixed 200x200 pixel images.
		
		It works by rendering an image to a 'canvas', and then querying that canvas for the pixel values.
		The downside is that the canvas is rendered, when not needed.
	*/
	var FF_Picture = function(filename) 
	{
		this.imageSrc = filename;
		
		this.myImg = new Image();
		this.myImg.src = filename;
		this.context = document.getElementById('outputPlotImageCanvas').getContext('2d');
		this.context.drawImage(this.myImg, 0, 0);
		
		// Pictures are assumed to be 200x200 pixels		
		var w = 200;
		var h = 200;
		this.dimensions = [ {min: 0, max: w}, {min: 0, max: h} ];
		
		// This doesn't make sense, but required by the display code.
		this.global = {x: 0, y: 0};
		
		this.compute = function (x, y) 
						{
							x = scale(x, this.dimensions[0]);
							y = scale(y, this.dimensions[1]);
							//console.log(this.dimensions[0].max);
							if ((x >= this.dimensions[0].min) && (x <= this.dimensions[0].max)
								&& (y >= this.dimensions[1].min) && (y <= this.dimensions[1].max)) 
							{
								var sample_x = x;
								var sample_y = this.dimensions[1].max - y;
								// Returns an ImageData object that copies the pixel data for the specified rectangle on a canvas
								var pixelData = this.context.getImageData(Math.floor(sample_x), Math.floor(sample_y), 1, 1).data;
								var f = 255 - (pixelData[0] + pixelData[1] + pixelData[2]);
								
								return f;
							} else {
								return Infinity;
							}
						}.bind(this);
	};
	
	// Load the user chosen fitness function
	switch (document.getElementById("inputFunction").value) {
		case "Salomon":
			this.ff = new FF_Salomon;
			break;
		case "Bohachevsky": 
  			this.ff = new FF_Bohachevsky;
  			break;
		case "Griewank":
			this.ff = new FF_Griewank;
			break;
		case "Michaelwicz":
			this.ff = new FF_Michaelwicz;
			break;
		default:
			console.assert(false);
	}
	
	document.getElementById("outputPlotImageContour").setAttribute("src",ff.imageSrcContour);
	document.getElementById("outputPlotImageThreeD").setAttribute("src",ff.imageSrcThreeD);


	document.getElementById("outputTruePosition").innerHTML = "( " + ff.global.x.toFixed(3) + ", " + ff.global.y.toFixed(3) + " )";
	var ips = parseFloat(document.getElementById("inputIterationsPerSecond").value);
	var numParticles = parseFloat(document.getElementById("inputNumParticles").value);
	
	// Create the main PSO computation object
	this.manager = new PSO.Manager( this.ff, numParticles );
	this.manager.inertiaWeight = parseFloat(document.getElementById("inputInertiaWeight").value);
	this.manager.socialWeight = parseFloat(document.getElementById("inputSocialWeight").value);
	this.manager.cognitiveWeight = parseFloat(document.getElementById("inputCognitiveWeight").value);
	
	switch (document.getElementById("inputTopology").value) {
		case "Ring":
			this.manager.topology = "ring";
			this.manager.numNeighbors = parseFloat(document.getElementById("inputNumNeighbors").value);
			break;
		case "Star":
			// this should be the manger's default (but set it to be sure)
			this.manager.topology = "star";
			this.manager.numNeighbors = parseFloat(this.manager.particles.length);
			break;
		default:
			console.assert(false);
	}
	
	// Create the PSO plot animator object
	this.plot = new PSOPlot (manager, "plot");
	this.plot.tickCallbackCallback = iterationCallback.bind(this);
	this.plot.iterationsPerSecond = ips;	
	this.plot.startAnimation();
	
	// Set the animation and computation stopping condition
	switch (document.getElementById("inputStoppingCondition").value) 
	{
		case "none":
			this.maxIterations = Infinity;
			break;
		case "100":
			this.maxIterations = 100;
			break;
		case "200":
			this.maxIterations = 200;
			break;
		case "300":
			this.maxIterations = 300;
			break;
		case "400":
			this.maxIterations = 400;
			break;
		case "500":
			this.maxIterations = 500;
			break;
		default:
			console.log("Invalid stopping condition.");
		 	console.assert(true);
	}
	
	this.simulationIsRunning = true;
	document.getElementById("toggleSimulationButton").innerHTML = "Stop Simulation";
}

toggleSimulation();

	
</script>

</body>

</html>
