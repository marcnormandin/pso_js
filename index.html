<!DOCTYPE html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=1024">
	<meta name="keywords" content="pso,d3,particle,swarm,optimization,interactive,javascript">
	<meta itemprop="description" name="description" content="Particle Swarm Optimization Interactive Javascript Applet">
	<meta name="author" content="Marc Normandin">
	
	<link rel="stylesheet" type="text/css" href="style.css">
	
	<title>Particle Swarm Optimization Interactive Demonstration by Marc Normandin</title>
	
	<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>	
	<script src="pso.js"></script>
	<script src="pso_plot.js"></script>

</head>

<body>

<div class="header">
<center>
<h2>Particle Swarm Optimization</h2>
<h3>Demonstration of <a href="https://github.com/marcnormandin/pso_js">pso_js</a> javascript code</h3>
<h4>Written by <i>Marc Normandin</i></h4>
</center>
</div> <!-- header -->

<br/>
<div class="pso_simulation">
	<div class="pso_plot">
		<svg id="plot" width="500" height="500" onclick="plot.toggleAnimation()"></svg>
		<button id="toggleSimulationButton" class="inactive" onclick="toggleSimulation()"></button>
	</div> <!-- pso_plot -->

	<div class="plot_info">
	<table>
		<tr>
			<td>Function</td>
			<td>
					<select id="inputFunction" onchange="startSimulation()">
					  <option value="Salomon">Function: Salomon</option>
					  <option value="Bohachevsky">Function: Bohachevsky</option>
					  <option value="Griewank">Function: Griewank</option>
					  <option value="Michaelwicz">Function: Michaelwicz</option>
					  <option value="Image: Noise #1">Image: Noise #1</option>
					  <option value="Image: Spiral">Image: Spiral</option>
					</select>
			</td>
			<td class="parameterHelpText">the function to minimize</td>
		</tr>
		<tr>
			<td>Topology</td>
			<td>
					<select id="inputTopology">
					  <option value="Ring">Ring (local best)</option>
					  <option value="Fully Connected">Fully Connected (global best)</option>
					</select>
			</td>
			<td class="parameterHelpText">how the particles communicate</td>
		</tr>
		<tr>
			<td># Neighbors</td>
			<td><input type="number" id="inputNumNeighbors" value="2"/></td>
			<td class="parameterHelpText">particle's peers<br/> (must be even #)</td>
		</tr>
		<tr>
			<td># Particles</td>
			<td><input type="number" id="inputNumParticles" value="50"/></td>
			<td class="parameterHelpText"></td>
		</tr>
		<tr>
          <td colspan="3"><hr/></td>
    	</tr>
		<tr>
			<td>Inertial weight</td>
			<td><input type="number" id="inputInertiaWeight" value="0.72984"/></td>
			<td class="parameterHelpText">particle's perseverance</td>
		</tr>
		<tr>
			<td>Social weight</td>
			<td><input type="number" id="inputSocialWeight" value="1.496172"/></td>
			<td class="parameterHelpText">particle's peer pressure</td>
		</tr>
		<tr>
			<td>Cognitive weight</td>
			<td><input type="number" id="inputCognitiveWeight" value="1.496172"/></td>
			<td class="parameterHelpText">particle's independence</td>
		</tr>
		<tr>
          <td colspan="3"><hr/></td>
    	</tr>
		<tr>
			<td>Iterations per second</td>
			<td><input type="number" id="inputIterationsPerSecond" value="20"/></td></tr>
		<tr>
			<td>Stopping condition</td>
			<td>
					<select id="inputStoppingCondition">
					  <option value="none">Never</option>
					  <option value="25">25 iterations</option>
					  <option value="50">50 iterations</option>
					  <option value="100">100 iterations</option>
					  <option value="200">200 iterations</option>
					  <option value="300">300 iterations</option>
					  <option value="400">400 iterations</option>
					  <option value="500">500 iterations</option>
					</select>
			</td>
			<td style="text-align: right;">
				(current iteration #<span id="outputNumIterations"></span>)
			</td>
		</tr>
		<tr>
			<td>Particle radius</td>
			<td><input type="number" id="inputParticleRadius" value="6"/></td>
			<td class="parameterHelpText">radius of particles in pixels</td>
		</tr>
		<tr>
			<td>Best Particle radius</td>
			<td><input type="number" id="inputBestParticleRadius" value="8"/></td>
			<td class="parameterHelpText">radius of best particle in pixels</td>
		</tr>
		<tr>
			<td>Best Minimum radius</td>
			<td><input type="number" id="inputMinimumRadius" value="10"/></td>
			<td class="parameterHelpText">radius of minimum in pixels</td>
		</tr>
		
		<tr>
			<td>
				Display Dust
			</td>
			<td>
				<input type="checkbox" id="inputDisplayDust" checked/>
			</td>
			<td class="parameterHelpText">display visited particle locations</td>
		</tr>
	</table>

	<!-- this is hidden. required for getting pixel data from the canvas. -->
	<canvas id="outputPlotImageCanvas" width="200" height="200" style="display: none;"> </canvas>
	</div> <!-- plot_info -->
</div> <!-- pso_simulation -->

<div style="clear:both;"></div>




<center>
<p>The best position found is: <span id="outputBestPosition"></span></p>
<p>The true global minimum is: <span id="outputTruePosition"></span></p>
</center>		

<center>
<br/>
<br/>
<br/>
<br/>
<br/>
<hr/>

<h3 class="subtitle">A three-dimensional plot of the function being minimized</h3>
<img id="outputPlotImageThreeD"/>

<hr/>

<br/>
<br/>
<br/>
<br/>
<br/>
<h3 class="subtitle">A two-dimensional contour plot of the function being minimized</h3>
<img id="outputPlotImageContour"/>
</center>

<div class="footer">
<h4>Written by <a href="http://github.com/marcnormandin">Marc Normandin</a>, &copy;2015</h4>
</div><!-- footer -->

		
<script>
	var numIterations = 0;
	var maxIterations = Infinity;
	
	// default value
	this.simulationIsRunning = false;
	
	function toggleSimulation() {
		if (!this.simulationIsRunning) {
			startSimulation();
		} else {
			stopSimulation();
		}
	}
	
	function stopSimulation() {
		this.simulationIsRunning = false;
		this.plot.stopAnimation = true;
		document.getElementById("toggleSimulationButton").innerHTML = "Start Simulation";
		document.getElementById("toggleSimulationButton").className = "inactive";
	}
	
	// Convert from PSO scale to Function scale
	function scale(xPSO, dimension) {
		var functionX = (0.5*dimension.max*(1+xPSO) + 0.5*dimension.min*(1-xPSO));
		return functionX;
	}
	
	// This is called every iteration of the PSO algorithm
	function iterationCallback (manager) {
		var x = scale(manager.bestPosition[0], this.ff.dimensions[0]);
		var y = scale(manager.bestPosition[1], this.ff.dimensions[1]);
		
		document.getElementById("outputBestPosition").innerHTML
			= "( " + x.toFixed(3) + ", " + y.toFixed(3) + " )";
		
		numIterations++;
		
		document.getElementById("outputNumIterations").innerHTML
			= numIterations;
			
		if (numIterations >= maxIterations) {
			stopSimulation();
			return false;
		}
		
		return true;
	}

	function displayContour (name) {
		// Display the contour if one is present
		if (name != "") {
			document.getElementById("outputPlotImageContour").style.display = "initial";
			document.getElementById("outputPlotImageContour").setAttribute("src", name);
		} else {
			document.getElementById("outputPlotImageContour").style.display = "none";
		}
	}
	
	function displayThreeD (name) {
		if (name != "") {
			document.getElementById("outputPlotImageThreeD").style.display = "initial";
			document.getElementById("outputPlotImageThreeD").setAttribute("src", name);
		} else {
			document.getElementById("outputPlotImageThreeD").style.display = "none";
		}
	}
	
	
	/*
		This is the main function in this HTML file.
		
		It begins a new simulation by querying the input elements
		for their data, and then creating a new PSO computation object
		as well as a new PSO plot animation object.
	*/
function startSimulation() {
	// Check if any current simulation is running. If so, end it.
	if (typeof this.plot !== 'undefined') {
		this.plot.stopAnimation = true;
	}
	
	document.getElementById("toggleSimulationButton").className = "active";




	numIterations = 0;
	
	
	
	var FF_Salomon = function() {
	
		this.dimensions = [ {min: -4, max: 4}, {min: -4, max: 4} ];
		this.global = {x: 0, y: 0};
		this.imageSrcContour = "http://i.imgur.com/3dg4gAL.jpg";
		this.imageSrcThreeD = "http://i.imgur.com/KcOFABP.png";
		
		this.compute = function (x, y) 
						{
							//console.log(this.dimensions[0].min);
							x = scale(x, this.dimensions[0]);
							y = scale(y, this.dimensions[1]);
							if ((x >= this.dimensions[0].min) && (x <= this.dimensions[0].max)
								&& (y >= this.dimensions[1].min) && (y <= this.dimensions[1].max)) 
							{
								var r = Math.sqrt(x*x + y*y);
								var f = 1 - Math.cos(2*Math.PI*r) + 0.1*r;
								return f;
							} else {
								return Infinity;
							}
						}
					.bind(this);
	};
	
	var FF_Bohachevsky = function() {
	
		this.dimensions = [ {min: -2, max: 2}, {min: -2, max: 2} ];
		this.global = {x: 0, y: 0};
		this.imageSrcContour = "http://i.imgur.com/phIMicg.png";
		this.imageSrcThreeD = "http://i.imgur.com/DZj4zdU.png";

		
		this.compute = function (x, y) 
						{
							//console.log(this.dimensions[0].min);
							x = scale(x, this.dimensions[0]);
							y = scale(y, this.dimensions[1]);
							if ((x >= this.dimensions[0].min) && (x <= this.dimensions[0].max)
								&& (y >= this.dimensions[1].min) && (y <= this.dimensions[1].max)) 
							{
								var f = x*x + 2 *y*y - 0.3*Math.cos(2*Math.PI*x) - 0.4*Math.cos(4*Math.PI*y) + 0.7;

								return f;
							} else {
								return Infinity;
							}
						}
					.bind(this);
	};
	
	var FF_Griewank = function() {
	
		this.dimensions = [ {min: -40, max: 40}, {min: -40, max: 40} ];
		this.global = {x: 0, y: 0};
		this.imageSrcContour = "http://i.imgur.com/vKt5dVe.png";
		this.imageSrcThreeD = "http://i.imgur.com/auPzgxp.png";

		this.compute = function (x, y) {
			x = scale(x, this.dimensions[0]);
			y = scale(y, this.dimensions[1]);
			if ((x >= this.dimensions[0].min) && (x <= this.dimensions[0].max)
				&& (y >= this.dimensions[1].min) && (y <= this.dimensions[1].max)) 
			{
				var f = 1 + ((1/4000)*(x*x+y*y))-(Math.cos(x)*Math.cos(y/Math.sqrt(2)));
				
				return f;
			} else {
				return Infinity;
			}
		}.bind(this);
	};
	
	var FF_Michaelwicz = function() {
	
		this.dimensions = [ {min: 0, max: 4}, {min: 0, max: 4} ];
		this.global = {x: 2.20319, y: 1.57049};
		this.imageSrcContour = "http://i.imgur.com/aHZ4751.png";
		this.imageSrcThreeD = "http://i.imgur.com/gNmFkhF.png";
		
		this.compute = function (x, y) {
			x = scale(x, this.dimensions[0]);
			y = scale(y, this.dimensions[1]);
			if ((x >= this.dimensions[0].min) && (x <= this.dimensions[0].max)
				&& (y >= this.dimensions[1].min) && (y <= this.dimensions[1].max)) 
			{
				var a = Math.sin(x*x / Math.PI);
				var b = Math.sin(2*y*y / Math.PI);
				var a20 = 1;
				var b20 = 1;
				for (var i = 0; i < 20; i++) {
					a20 *= a;
					b20 *= b;
				}
				var f = -Math.sin(x)*a20 - Math.sin(y)*b20;
				
				return f;
			} else {
				return Infinity;
			}
		}.bind(this);
	};
	
	/*
		This Fitness Function uses an image (translated to grey-scale) as the fitness function values.
		It assumes fixed 200x200 pixel images.
		
		It works by rendering an image to a 'canvas', and then querying that canvas for the pixel values.
		The downside is that the canvas is rendered, when not needed.
	*/
	var FF_Image = function(filename) 
	{
		this.imageSrc = filename;
		this.imageSrcContour = "";
		this.imageSrcThreeD = "";
		
		this.myImg = new Image();
		this.myImg.src = filename;
		this.context = document.getElementById('outputPlotImageCanvas').getContext('2d');
		this.context.drawImage(this.myImg, 0, 0);
		
		// Pictures are assumed to be 200x200 pixels		
		var w = 200;
		var h = 200;
		this.dimensions = [ {min: 0, max: w}, {min: 0, max: h} ];
		
		this.compute = function (x, y) 
						{
							x = scale(x, this.dimensions[0]);
							y = scale(y, this.dimensions[1]);
							//console.log(this.dimensions[0].max);
							if ((x >= this.dimensions[0].min) && (x <= this.dimensions[0].max)
								&& (y >= this.dimensions[1].min) && (y <= this.dimensions[1].max)) 
							{
								var sample_x = x;
								var sample_y = this.dimensions[1].max - y;
								// Returns an ImageData object that copies the pixel data for the specified rectangle on a canvas
								var pixelData = this.context.getImageData(Math.floor(sample_x), Math.floor(sample_y), 1, 1).data;
								var f = 255 - (pixelData[0] + pixelData[1] + pixelData[2]);
								
								return f;
							} else {
								return Infinity;
							}
						}.bind(this);
	};
	
	// Load the user chosen fitness function
	switch (document.getElementById("inputFunction").value) {
		case "Salomon":
			this.ff = new FF_Salomon;
			break;
		case "Bohachevsky": 
  			this.ff = new FF_Bohachevsky;
  			break;
		case "Griewank":
			this.ff = new FF_Griewank;
			break;
		case "Michaelwicz":
			this.ff = new FF_Michaelwicz;
			break;
		case "Image: Noise #1":
			this.ff = new FF_Image("http://www.revisemri.com/tools/kspace/images/k_randnoise.jpg");
			break;
		case "Image: Spiral":
			this.ff = new FF_Image("http://www.gifwave.com/media/102045_art-processing-adam-ferriss-p5-ellipse_200s.gif");
			break;
		default:
			console.assert(false);
	}
	
	displayContour(ff.imageSrcContour);
	displayThreeD(ff.imageSrcThreeD);
	
	if (typeof(ff.global) !== 'undefined') {
		document.getElementById("outputTruePosition").innerHTML = "( " + ff.global.x.toFixed(3) + ", " + ff.global.y.toFixed(3) + " )";
	} else {
		document.getElementById("outputTruePosition").innerHTML = "<i>not applicable</i>";
	}
	
	var ips = parseFloat(document.getElementById("inputIterationsPerSecond").value);
	var numParticles = parseFloat(document.getElementById("inputNumParticles").value);
	
	// Create the main PSO computation object
	this.manager = new PSO.Manager( this.ff, numParticles );
	this.manager.inertiaWeight = parseFloat(document.getElementById("inputInertiaWeight").value);
	this.manager.socialWeight = parseFloat(document.getElementById("inputSocialWeight").value);
	this.manager.cognitiveWeight = parseFloat(document.getElementById("inputCognitiveWeight").value);
	
	switch (document.getElementById("inputTopology").value) {
		case "Ring":
			this.manager.topology = "ring";
			this.manager.numNeighbors = parseFloat(document.getElementById("inputNumNeighbors").value);
			break;
		case "Fully Connected":
			// this should be the manger's default (but set it to be sure)
			this.manager.topology = "fully connected";
			this.manager.numNeighbors = parseFloat(this.manager.particles.length);
			break;
		default:
			console.assert(false);
	}
	
	// Create the PSO plot animator object
	this.plot = new PSOPlot (manager, "plot");
	this.plot.normalParticleRadius = parseFloat(document.getElementById("inputParticleRadius").value);
	this.plot.bestParticleRadius = parseFloat(document.getElementById("inputBestParticleRadius").value);;
	this.plot.bestMinimumRadius = parseFloat(document.getElementById("inputMinimumRadius").value);;
	this.plot.tickCallbackCallback = iterationCallback.bind(this);
	this.plot.iterationsPerSecond = ips;
	if (document.getElementById("inputDisplayDust").checked) {
		this.plot.featureDisplayDustEnabled = true;
	} else {
		this.plot.featureDisplayDustEnabled = false;
	}
	this.plot.featureDisplayDust
	this.plot.startAnimation();
	
	// Set the animation and computation stopping condition
	switch (document.getElementById("inputStoppingCondition").value) 
	{
		case "none":
			this.maxIterations = Infinity;
			break;
		case "25":
			this.maxIterations = 25;
			break;
		case "50":
			this.maxIterations = 50;
			break;
		case "100":
			this.maxIterations = 100;
			break;
		case "200":
			this.maxIterations = 200;
			break;
		case "300":
			this.maxIterations = 300;
			break;
		case "400":
			this.maxIterations = 400;
			break;
		case "500":
			this.maxIterations = 500;
			break;
		default:
			console.log("Invalid stopping condition.");
		 	console.assert(true);
	}
	
	this.simulationIsRunning = true;
	document.getElementById("toggleSimulationButton").innerHTML = "Stop Simulation";
}

toggleSimulation();

	
</script>

</body>

</html>
